var ProviderError = require('./error');
module.exports = {
    wrap: function (provider, options) {
        if (provider._alreadyWrapped)
            return provider;
        options = options || {};
        options.logger = options.logger || console;
        options.verbose = options.verbose || options.verboseRpc || false;
        var preHook = this.preHook(options);
        var postHook = this.postHook(options);
        var originalSend = provider.send.bind(provider);
        var originalSendAsync = provider.sendAsync.bind(provider);
        provider.send = this.send(originalSend, preHook, postHook);
        provider.sendAsync = this.sendAsync(originalSendAsync, preHook, postHook);
        provider._alreadyWrapped = true;
        return provider;
    },
    preHook: function (options) {
        return function (payload) {
            if (options.verbose) {
                options.logger.log("   > " + JSON.stringify(payload, null, 2).split("\n").join("\n   > "));
            }
            return payload;
        };
    },
    postHook: function (options) {
        return function (payload, error, result) {
            if (error != null) {
                error = new ProviderError(error.message, error);
                return [payload, error, result];
            }
            if (options.verbose) {
                options.logger.log(" <   " + JSON.stringify(result, null, 2).split("\n").join("\n <   "));
            }
            return [payload, error, result];
        };
    },
    send: function (originalSend, preHook, postHook) {
        return function (payload) {
            var result = null;
            var error = null;
            payload = preHook(payload);
            try {
                result = originalSend(payload);
            }
            catch (e) {
                error = e;
            }
            var modified = postHook(payload, error, result);
            payload = modified[0];
            error = modified[1];
            result = modified[2];
            if (error != null) {
                throw error;
            }
            return result;
        };
    },
    sendAsync: function (originalSendAsync, preHook, postHook) {
        return function (payload, callback) {
            payload = preHook(payload);
            originalSendAsync(payload, function (error, result) {
                var modified = postHook(payload, error, result);
                payload = modified[0];
                error = modified[1];
                result = modified[2];
                callback(error, result);
            });
        };
    }
};
//# sourceMappingURL=wrapper.js.map